> ## 시간 복잡도란?
#### 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계
어떠한 알고리즘의 로직이 얼마나 오랜 시간이 걸리는지를 나타내는 데 쓰인다.

<br>

## 빅오 표기법
입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것
- 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없애서 표현한다. 입력 데이터의 값이 커질 수록 나머지 항은 큰 영향을 끼치지 않기 때문이다.
- ex) 알고리즘에 필요한 시간 ```10n^2 + n``` ➡ 빅오표기법 ```O(n^2)```

<br>

## 시간 복잡도의 존재 이유
효율적인 코드로 개선하는 데 쓰이는 척도가 되기 때문이다.
시간 복잡도가 비효율적일 경우, 입력 데이터의 양이 많으면 많아질 수록 효율적인 알고리즘과 실행 속도 차이가 커진다.

<br>

⭐버튼을 누르면 화면이 나타나는 로직이 ```O(n^2)```의 시간 복잡도를 가지고 ```9초```가 걸린다고 치자.
⭐이것을 ```O(n)```의 시간 복잡도를 가지는 알고리즘으로 개선한다면 ```3초```가 걸리게 될 것이다.
⭐이것을 ```O(1)```의 시간 복잡도를 가지는 알고리즘으로 개선한다면 ```1초```가 걸리게 될 것이다.

<br>

### 빅오 표기법으로 보기
### 1. O(1) (constant)
입력데이터의 크기에 상관없이 언제나 처리속도는 동행하게 이루어진다.
ex) sorted Array search

### 2. O(log n) (logarithmic)
입력데이터의 크기가 커지더라도 처리속도가 크게 달라지지 않으며, 실행시간이 지날수록 처리해야 하는 데이터의 양이 절반으로 줄어드며 실행 시간은 증가하지만 속도는 감소한다.
ex) Binary search

### 3. O(n) (linear)
입력데이터의 크기에 비례해서 처리시간이 증가해 메모리의 사용이 정비례 한다(step : size = 1 : 1).
ex) search linked list, for문을 이용한 array 검색

### 4. O(n^2) (quadratic)
입력데이터의 크기에 따라 걸리는 시간은 제곱에 비례한다.
ex) 이중 for문

### 5. O(C^n) (exponential)
문제를 해결하기 위한 단계의 수는 주어진 상수값 C의 n제곱이다.
ex) 피보나치 수열, recursio

<br><br><br><br>

> ## 공간 복잡도란?
#### 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양


### 예시 )
```int a[1000]```
a 배열은 1000 * 4 바이트의 크기를 가지게 된다. 이게 공간복잡도이다.

<br><br><br><br>

## 자주 쓰는 자료 구조에서의 시간 복잡도

![](https://velog.velcdn.com/images/jjoyewon/post/0b4c40a6-e63d-4d98-a90e-e5e4eedd6c5a/image.png)

<br><br><br>

> ### Reference
- 면접을 위한 CS 전공지식노트 - 주홍철 저
- https://velog.io/@ollabu3/codestates-immersive-TIL-4